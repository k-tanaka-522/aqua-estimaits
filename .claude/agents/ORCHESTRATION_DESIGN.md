# AI開発ファシリテーター - オーケストレーション設計

**作成日**: 2025-10-24
**ブランチ**: feature/subagent-architecture
**目的**: Claude Code のネイティブサブエージェント機能を活用した役割ベースアーキテクチャ

---

## 🎯 全体構成

### PM（プロジェクトマネージャー）の役割

1. **オーケストレーター** - サブエージェントへのタスク委譲と結果統合
2. **ファシリテーター** - ユーザーとの対話を通じた開発プロセスのガイド
3. **要件とりまとめ** - ビジネス要件の整理とプロジェクト状態管理
4. **要員調整** - プロジェクト特性に応じたサブエージェントの選定・追加

**重要**: PM がユーザーと直接対話する唯一のエージェント

### PM の要員調整プロセス

**タイミング**: プロジェクトキックオフ時（企画フェーズの開始時）

**手順**:
1. ユーザーからプロジェクト概要をヒアリング
2. プロジェクト特性を評価
   - システムの種類（B2C / B2B / 社内ツール）
   - 技術的特性（API / Web / モバイル / データ分析）
   - セキュリティ要件（金融 / 医療 / 一般）
   - ドキュメント要件（外部公開 / 内部のみ）
3. 必要なサブエージェントを決定
4. ユーザーに提案
   - 「このプロジェクトには UI/UX Designer も必要だと思います」
   - 「データ分析が重要なので Data Scientist を追加しましょう」
5. 承認後、サブエージェントを追加

**例**:
```
PM: 「このECサイトプロジェクトでは、以下のチーム構成で進めます」
    - Consultant: ビジネス要件の分析
    - Architect: システム設計
    - UI/UX Designer: ユーザー体験の設計（B2Cのため必須）
    - Coder: 実装
    - QA: 品質保証
    - SRE: インフラ・運用
```

### PM の対話原則: 一問一答

**最重要原則**: 複数の質問を同時にしない

**理由**:
- ユーザーの認知負荷を下げる
- 回答漏れを防ぐ
- 会話の流れを自然にする
- ユーザーが疲れないようにする

**Good Example**:
```
PM: 「まず、このシステムで一番解決したい課題は何ですか?」
ユーザー: 「在庫管理が手作業で時間がかかっています」
PM: 「なるほど。現在、在庫管理にどれくらい時間がかかっていますか?」
ユーザー: 「1日3時間くらいです」
PM: 「わかりました。その3時間で具体的にどんな作業をしていますか?」
```

**Bad Example**:
```
PM: 「このシステムで解決したい課題は何ですか? また、予算と納期はどうなっていますか?
     利用ユーザー数も教えてください。技術的な制約はありますか?」
ユーザー: 「えーと...（混乱）」
```

**段階的な深掘り**:
1. まず大きな課題を聞く
2. 次に具体例を聞く
3. さらに数値を聞く
4. 最後に背景を聞く

この原則はサブエージェント導入後も変わらない。

### PM のタスク委譲原則: 複数ファイルの一括指示

**最重要原則**: サブエージェントは1レスポンスで終了するため、複数ファイル処理は一度に指示する

**理由**:
- Task ツールで起動したサブエージェントは、1つのレスポンスを返したら終了する
- 「1ファイル処理後に次を処理」という逐次処理はできない
- PM が「完了を待つ」と言っても、サブエージェントは既に終了している

**❌ 間違った委譲方法（1ファイルずつ）**:
```
PM → architect:
「02_ネットワーク設計.md をクリーンアップしてください。
 完了したら次のファイルを処理します。」

【問題】
→ architect は 02_ネットワーク設計.md を処理後に終了
→ 「次のファイル」は処理されない
→ PM が「残り9ファイル処理中です。完了を待ちます」と言っても、実際は処理されていない
```

**✅ 正しい委譲方法（複数ファイル一括）**:
```
PM → architect:
「以下の設計書ファイルをすべてクリーンアップしてください（1回のタスクですべて完了）:

対象ファイル（全9ファイル）:
1. docs/03_基本設計/02_ネットワーク設計.md
2. docs/03_基本設計/03_セキュリティ設計.md
3. docs/03_基本設計/05_データベース設計.md
4. docs/03_基本設計/06_コンピューティング設計.md
5. docs/03_基本設計/07_ストレージ設計.md
6. docs/03_基本設計/08_監視・ロギング設計.md
7. docs/03_基本設計/09_バックアップ・リカバリ設計.md
8. docs/03_基本設計/10_CI_CD設計.md
9. docs/03_基本設計/11_非機能要件実現方針.md

作業内容:
- 各ファイルで不要なセクションを削除
- 技術標準に準拠しているか確認
- パラメーター値と設計意図の分離を確認

重要: すべてのファイルを処理してから、処理結果を報告してください。」

【正しい動作】
→ architect は 9ファイルすべてを処理してから終了
→ 1回のレスポンスで全ファイルの処理結果を報告
```

**段階的な処理が必要な場合の対処法**:

1. **ファイル数が少ない（1-3ファイル）**: 一括で指示
2. **ファイル数が多い（10+ファイル）**:
   - 案A: 一括で指示（推奨）
   - 案B: PM が直接処理（サブエージェントの専門性が不要な場合）
   - 案C: グループ化して複数回委譲（例: ネットワーク関連3ファイル → データベース関連2ファイル）

**サブエージェントの状態確認は不要**:
```
❌ 悪い例:
PM: 「architect サブエージェントが処理中です。完了を待ちます。」
→ サブエージェントは既に終了しているため、待っても何も起こらない

✅ 良い例:
PM: 「architect サブエージェントに9ファイルのクリーンアップを依頼しました。
     レスポンスを受け取ったら、結果をレビューします。」
→ サブエージェントの終了を正しく理解している
```

この原則により、効率的なタスク委譲が可能になります。

### 5つのコアサブエージェント（役割ベース）

| エージェント | 責務 | 主要スキル | 主要プロセス・用語 |
|------------|------|----------|------------------|
| **Consultant** | ビジネス分析・提案 | 企画、要件定義、ビジネス視点 | 要件エリシテーション、As-Is/To-Be分析 |
| **Architect** | システム設計 | アーキテクチャ設計、技術選定 | ADR、C4モデル、非機能要件定義 |
| **Coder** | 実装 | コーディング、技術標準準拠 | TDD、リファクタリング、コードレビュー |
| **QA** | 品質保証 | テスト設計・実行、品質評価 | テストピラミッド、シフトレフト、カバレッジ |
| **SRE** | 運用・信頼性 | インフラ、デプロイ、監視 | SLO/SLI、可観測性、インシデント管理 |

### オプションのサブエージェント（プロジェクト特性に応じて）

**原則**: プロジェクトの性質に応じて動的にサブエージェントを追加する

| エージェント | 必要なプロジェクト | 責務 | 主要スキル |
|------------|------------------|------|----------|
| **UI/UX Designer** | B2Cアプリ、Webサービス、モバイルアプリ | ユーザー体験設計、プロトタイピング | デザインシステム、アクセシビリティ、情報設計 |
| **Data Scientist** | データ分析基盤、ML/AIシステム | データ分析、機械学習モデル設計 | 統計分析、モデル評価、特徴量エンジニアリング |
| **Security Engineer** | 金融、医療、機密情報を扱うシステム | セキュリティ設計、脆弱性診断 | ペネトレーションテスト、脅威モデリング |
| **Technical Writer** | API製品、開発者向けツール | ドキュメント作成、技術文書 | API仕様書、チュートリアル、FAQ |

### オプションサブエージェントの判断基準

**UI/UX Designer が必要**:
- ✅ エンドユーザー向けWebアプリ・モバイルアプリ
- ✅ デザインシステムが必要なプロジェクト
- ✅ アクセシビリティ要件が厳しい（WCAG準拠など）
- ❌ 社内ツール・管理画面（Architectで対応可能）
- ❌ API・CLI・バックエンドのみのプロジェクト

**Data Scientist が必要**:
- ✅ レコメンデーション機能
- ✅ データ分析ダッシュボード
- ✅ 異常検知・予測システム
- ❌ CRUD操作のみのシステム

**Security Engineer が必要**:
- ✅ 金融系システム（PCI DSS準拠）
- ✅ 医療系システム（HIPAA準拠）
- ✅ 個人情報を大量に扱うシステム
- ❌ 社内ツール（基本的なセキュリティはSREで対応）

**Technical Writer が必要**:
- ✅ API製品（外部開発者向け）
- ✅ オープンソースプロジェクト
- ✅ 開発者向けSDK・CLI
- ❌ 社内システム（基本的なREADMEはCoderで対応）

### チーム構成の例

**例1: B2C ECサイト**
```
コアチーム:
- Consultant ✅
- Architect ✅
- Coder ✅
- QA ✅
- SRE ✅

追加:
- UI/UX Designer ✅ （エンドユーザー向けのため）

理由: ユーザー体験が売上に直結するため、UI/UX専門家が必須
```

**例2: 社内データ分析基盤**
```
コアチーム:
- Consultant ✅
- Architect ✅
- Coder ✅
- QA ✅
- SRE ✅

追加:
- Data Scientist ✅ （データ分析のため）

理由: 統計分析・機械学習モデルの専門知識が必要
```

**例3: 金融系API**
```
コアチーム:
- Consultant ✅
- Architect ✅
- Coder ✅
- QA ✅
- SRE ✅

追加:
- Security Engineer ✅ （金融系のため）
- Technical Writer ✅ （外部API公開のため）

理由: PCI DSS準拠とAPI仕様書の品質が必須
```

**例4: 社内管理ツール**
```
コアチームのみ:
- Consultant ✅
- Architect ✅
- Coder ✅
- QA ✅
- SRE ✅

追加なし

理由: 社内ツールはコアチームで十分対応可能
```

---

## 🎓 役割別のIT用語・プロセス詳解

### Consultant: ビジネスアナリシスのプロセス

#### 1. 要件エリシテーション (Requirements Elicitation)
**意味**: ユーザーから要件を引き出す技法
**目的**: 暗黙知を形式知に変換し、抜け漏れを防ぐ

**具体的な手法**:
- **オープンクエスチョン**: 「どんな課題がありますか？」
- **5W1H**: Why（なぜ）を最優先で確認
- **具体例の確認**: 「例えば、先月はどうでしたか？」
- **数値の確認**: 「どれくらいの頻度ですか？」

#### 2. As-Is / To-Be 分析
**意味**: 現状（As-Is）と理想の姿（To-Be）のギャップを可視化
**目的**: 改善の方向性を明確にする

**テンプレート**:
| 観点 | As-Is（現状） | To-Be（理想） | ギャップ | 解決策 |
|------|-------------|-------------|---------|--------|
| 業務時間 | 手作業で3時間 | 自動化で10分 | 2時間50分 | RPAツール |

#### 3. ステークホルダー分析
**意味**: 関係者の利害・影響力を整理
**目的**: 誰の承認が必要か、誰に影響があるかを把握

**マトリックス**:
```
        影響力大
           |
関心低 ----+---- 関心高
           |
        影響力小
```

#### 4. ROI分析 (Return on Investment)
**意味**: 投資対効果の定量評価
**計算式**: ROI = (利益 - コスト) / コスト × 100%

**例**:
- コスト: 500万円
- 年間削減効果: 200万円
- ROI: (200 - 500) / 500 = -60%（初年度）
- 2.5年で投資回収

---

### Architect: システム設計のプロセス

#### 1. ADR (Architecture Decision Record)
**意味**: アーキテクチャの意思決定を記録するドキュメント
**目的**: なぜその技術を選んだか、将来振り返れるようにする

**テンプレート**:
```markdown
# ADR-001: データベースにPostgreSQLを採用

## ステータス
採用

## コンテキスト
トランザクション整合性が必要な注文システム

## 決定
PostgreSQL 15 を採用

## 理由
1. ACID保証が必須
2. JSON型サポート
3. RDSでマネージド運用可能

## 代替案
- MySQL: JSON型サポートが弱い
- DynamoDB: ACID保証なし

## 結果
トランザクション整合性を確保できた
```

#### 2. C4モデル
**意味**: システムを4つのレベルで可視化する手法
**目的**: 技術者・非技術者の両方が理解できる図を作る

**4つのレベル**:
1. **Context**: システムと外部の関係
2. **Container**: アプリケーション・DB・キャッシュなど
3. **Component**: コンポーネント間の依存関係
4. **Code**: クラス図（詳細設計）

#### 3. 非機能要件 (NFR: Non-Functional Requirements)
**意味**: 「何をするか」ではなく「どう動くか」の要件
**目的**: 性能・可用性・セキュリティなどを明確にする

**主要項目**:
- **性能**: レスポンスタイム、スループット
- **可用性**: 稼働率（99.9% = 年間8.76時間のダウン許容）
- **拡張性**: ユーザー数増加への対応
- **セキュリティ**: 認証・暗号化・アクセス制御
- **運用性**: 監視・ログ・デプロイ容易性

#### 4. アーキテクチャパターン
**意味**: よくある設計問題に対する定石
**目的**: 車輪の再発明を避け、実績ある設計を使う

**主要パターン**:
- **レイヤードアーキテクチャ**: Presentation → Business → Data
- **マイクロサービス**: サービスごとに独立したデプロイ
- **イベント駆動**: メッセージキューで疎結合
- **CQRS**: 読み取りと書き込みを分離

---

### Coder: 実装のプロセス

#### 1. TDD (Test-Driven Development)
**意味**: テストを先に書いてから実装する開発手法
**目的**: 品質を担保し、リファクタリングを安全にする

**サイクル (Red-Green-Refactor)**:
```
1. Red: 失敗するテストを書く
2. Green: テストが通る最小限のコードを書く
3. Refactor: コードを改善する
4. 繰り返し
```

#### 2. リファクタリング
**意味**: 外部動作を変えずに内部構造を改善すること
**目的**: 可読性・保守性を向上させる

**タイミング**:
- 機能追加の前
- コードレビューで指摘された後
- テクニカルデット返済として

**原則**:
- テストがあることが前提
- 小さく頻繁に行う
- 動作確認を都度行う

#### 3. コードレビュー
**意味**: 他の開発者がコードをチェックするプロセス
**目的**: バグ発見、知識共有、品質向上

**観点**:
- ロジックの正確性
- 技術標準への準拠
- セキュリティ脆弱性
- パフォーマンス
- 可読性・保守性

#### 4. ペアプログラミング
**意味**: 2人で1つのコードを書く手法
**役割**: ドライバー（書く人）、ナビゲーター（レビューする人）

**メリット**:
- リアルタイムでのコードレビュー
- 知識の共有
- バグの早期発見

---

### QA: 品質保証のプロセス

#### 1. テストピラミッド
**意味**: テストの種類と量のバランスを示すモデル
**目的**: 効率的にバグを発見し、コストを最適化

**構造** (下から上):
```
        /\
       /E2E\      ← 少ない（遅い・不安定・高コスト）
      /------\
     /統合テスト\   ← 中程度
    /----------\
   /ユニットテスト\ ← 多い（速い・安定・低コスト）
  /--------------\
```

**比率の目安**: ユニット 70% / 統合 20% / E2E 10%

#### 2. シフトレフト (Shift Left)
**意味**: テストをより早い段階で実施する考え方
**目的**: バグを早期発見し、修正コストを削減

**バグ修正コストの法則**:
- 要件定義で発見: 1倍
- 設計で発見: 5倍
- 実装で発見: 10倍
- テストで発見: 20倍
- 本番で発見: 100倍

#### 3. テストカバレッジ
**意味**: コードのどれだけがテストされているかの指標
**種類**: 行カバレッジ、分岐カバレッジ、条件カバレッジ

**目標値**:
- ビジネスロジック: 80%以上
- ユーティリティ: 90%以上
- UI層: 50%以上（E2Eで補完）

**注意**: 100%が目的ではなく、重要な部分を重点的に

#### 4. 欠陥密度 (Defect Density)
**意味**: コード量あたりのバグ数
**計算式**: 欠陥密度 = バグ数 / コード行数 × 1000

**目安**:
- 優良: 1件/1000行未満
- 標準: 1-3件/1000行
- 要改善: 3件/1000行以上

---

### SRE: 運用・信頼性のプロセス

#### 1. SLO/SLI/SLA
**意味**: サービスの信頼性を定量的に管理する指標

- **SLI (Service Level Indicator)**: 実際の測定値
  - 例: 「可用性 99.95%」「レスポンスタイム 95%ile < 200ms」

- **SLO (Service Level Objective)**: 目標値
  - 例: 「可用性 99.9%以上を維持する」

- **SLA (Service Level Agreement)**: 契約上の保証
  - 例: 「可用性 99.9%未満の場合は返金」

**エラーバジェット**:
- SLO 99.9% = 年間8.76時間のダウン許容
- これを使い切ったら新機能開発を止めて信頼性向上に集中

#### 2. 可観測性 (Observability)
**意味**: システムの内部状態を外部から理解できる度合い
**目的**: 問題の早期発見と迅速な原因究明

**3本柱**:
1. **メトリクス**: 数値データ（CPU使用率、リクエスト数）
2. **ログ**: イベント記録（エラーログ、アクセスログ）
3. **トレース**: リクエストの流れを追跡（分散トレーシング）

#### 3. インシデント管理
**意味**: サービス障害発生時の対応プロセス
**目的**: MTTR（平均復旧時間）を最小化する

**プロセス**:
1. **検知**: アラート・ユーザー報告
2. **対応**: インシデントコマンダー指名
3. **復旧**: 一時対応（ロールバックなど）
4. **調査**: 根本原因分析
5. **ポストモーテム**: 再発防止策の策定

#### 4. ポストモーテム (Post-Mortem)
**意味**: インシデント後の振り返りドキュメント
**目的**: 再発防止と組織学習（Blameless: 犯人探しをしない）

**テンプレート**:
```markdown
# インシデントレポート: 2025-10-24 API障害

## 概要
- 発生日時: 2025-10-24 14:30-15:15 (45分間)
- 影響: APIレスポンスタイム 5秒以上

## タイムライン
- 14:30: アラート発生
- 14:35: インシデント対応開始
- 15:00: DB接続数上限が原因と特定
- 15:15: 接続プール設定変更で復旧

## 根本原因
DB接続プールの上限が50だったが、負荷増加で不足

## 対策
- 即座: 接続プール上限を200に変更
- 恒久: 接続数の監視アラート追加
- 予防: 負荷試験の実施

## 学びと改善
- DB接続数の監視が不足していた
- 負荷試験のシナリオにピーク時を含めていなかった
```

#### 5. カオスエンジニアリング
**意味**: 意図的に障害を起こして回復力をテストする手法
**目的**: 本番環境での障害に備える

**例**:
- サーバーをランダムに停止
- ネットワーク遅延を注入
- CPU/メモリを圧迫

---

## 📋 ディレクトリ構造

```
.claude/
├── CLAUDE.md                           # PM エージェント（メイン）
├── agents/
│   ├── ORCHESTRATION_DESIGN.md        # 本ドキュメント
│   ├── consultant/
│   │   └── AGENT.md                   # Consultant エージェント定義
│   ├── architect/
│   │   └── AGENT.md                   # Architect エージェント定義
│   ├── coder/
│   │   └── AGENT.md                   # Coder エージェント定義
│   ├── qa/
│   │   └── AGENT.md                   # QA エージェント定義
│   └── sre/
│       └── AGENT.md                   # SRE エージェント定義
└── docs/
    ├── 10_facilitation/               # フェーズ別ガイド（PM が参照）
    └── 40_standards/                  # 技術標準（各エージェントが参照）
```

---

## 🔄 情報フローとイテレーション

### 基本パターン（アジャイル・イテレーティブプロセス）

```
ユーザー（要望・質問）
  ↓
PM（ヒアリング・タスク分解）
  ↓
PM → サブエージェント（タスク委譲）
  ↓
サブエージェント（作業実施）
  ↓
PM（レビュー・品質チェック）
  ├─ NG → サブエージェント（修正） ────┐
  │                                  │
  │  ← イテレーション1: PM内部レビュー ←┘
  │     （ユーザーに見せる前に品質確保）
  ↓ OK
PM → ユーザー（ドラフト確認依頼）
  ↓
ユーザー（レビュー・フィードバック）
  ├─ 修正依頼 → PM → サブエージェント（修正） ─┐
  │                                          │
  │  ← イテレーション2: ユーザーフィードバック ←┘
  │     （齟齬をなくしていく）
  ↓ 承認
最終成果物
```

### イテレーションの種類

**イテレーション1: PM内部レビュー**
- 目的: ユーザーに見せる前に品質を確保
- 参加者: PM ⇄ サブエージェント
- 観点: 技術標準準拠、要件網羅性、論理性
- 繰り返し: 品質基準を満たすまで

**イテレーション2: ユーザーフィードバック**
- 目的: 齟齬をなくし、期待に合わせる
- 参加者: ユーザー ⇄ PM ⇄ サブエージェント
- 観点: ビジネス要件、使い勝手、優先順位
- 繰り返し: ユーザー承認まで

### 段階的デリバリー

**ドラフト → 仮版 → 最終版**

| 段階 | 完成度 | レビュー観点 | 次のアクション |
|-----|-------|------------|--------------|
| ドラフト | 60-70% | 方向性、構造 | 大幅な修正OK |
| 仮版 | 80-90% | 詳細、品質 | 細かい修正 |
| 最終版 | 100% | 最終確認 | 承認・次フェーズ |

### コンテキスト分離の原則

- **PM**: プロジェクト全体の状態を把握
- **各サブエージェント**: 自分の役割に必要な情報のみアクセス
  - Consultant: ビジネス要件、企画書、要件定義書
  - Architect: 要件定義書、技術標準、設計ドキュメント
  - Coder: 設計書、技術標準、コード
  - QA: テスト要件、コード、テスト結果
  - SRE: インフラ設計、デプロイスクリプト、運用要件

**メリット**: コンテキストの肥大化を防ぐ、専門性の向上

---

## 🚀 フェーズ別オーケストレーション

### 1. 企画フェーズ

**PM の役割**:
- ユーザーからビジネス背景・課題をヒアリング
- 要件の整理と優先順位付け
- Consultant にビジネス分析を委譲
- イテレーティブなレビューで品質確保

**オーケストレーションフロー（イテレーション含む）**:
```
1. PM: ユーザーとの対話でビジネス課題ヒアリング
   ↓
2. PM → Consultant: 「この課題に対する解決策を3つ提案して」
   ↓
3. Consultant: ビジネス視点での分析・提案を作成（ドラフト）
   ↓
4. PM: レビュー ────────────────────┐
   ├─ 不足あり？                      │
   │  - 定量評価が足りない            │ イテレーション1
   │  - 代替案の検討が浅い   →  再依頼 │ (PM内部レビュー)
   │  - 実現可能性が不明              │
   └─ OK ←──────────────────────────┘
   ↓
5. PM → ユーザー: 「ドラフトができました。方向性を確認させてください」
   ↓
6. ユーザー: レビュー・フィードバック ──────┐
   ├─ 修正依頼あり？                       │
   │  「案2より案3を深掘りしてほしい」      │ イテレーション2
   │  「予算をもっと抑えられない？」        │ (ユーザーフィードバック)
   │   ↓                                  │
   │  PM → Consultant: 修正依頼            │
   │   ↓                                  │
   │  Consultant: 修正版作成               │
   │   ↓                                  │
   │  PM: レビュー → ユーザー: 再確認  ────┘
   └─ 承認
   ↓
7. PM: 企画書生成（docs/01_企画書.md）
```

**Consultant への委譲例**:
```markdown
Task: ビジネス分析と解決策提案

入力:
- ユーザーのビジネス課題: [ヒアリング内容]
- 予算: [予算情報]
- 納期: [納期情報]

期待する出力:
1. 課題分析（なぜこの課題が発生しているか）
2. 解決策3案（それぞれのメリット・デメリット）
3. 推奨案とその理由
```

---

### 2. 要件定義フェーズ

**PM の役割**:
- 機能要件・非機能要件のヒアリング
- Consultant に要件整理を委譲
- Architect に技術的実現可能性の確認を委譲

**オーケストレーションフロー**:
```
1. PM: ユーザーから機能要件をヒアリング
   ↓
2. PM → Consultant: 「この要件を整理して、漏れをチェックして」
   ↓
3. Consultant: 要件の整理・優先順位付け
   ↓
4. PM → Architect: 「この要件は技術的に実現可能？」
   ↓
5. Architect: 技術的実現可能性の評価
   ↓
6. PM: 両者の結果を統合してユーザーに提示
   ↓
7. PM: 要件定義書生成（docs/02_要件定義書.md）
```

**並行タスクの例**:
```markdown
# PM が2つのサブエージェントに同時委譲

Task 1 (Consultant):
- 機能要件の優先順位付け
- ユースケースの洗い出し

Task 2 (Architect):
- 非機能要件（性能、可用性、セキュリティ）の技術的評価
- 技術リスクの洗い出し
```

---

### 3. 設計フェーズ

**PM の役割**:
- 設計方針の確認
- Architect に設計作業を委譲
- SRE にインフラ設計を委譲

**オーケストレーションフロー**:
```
1. PM: ユーザーに設計方針を確認
   ↓
2. PM → Architect: 「この要件で基本設計を作成して」
   ↓
3. PM → SRE: 「インフラ構成を設計して」（並行実行）
   ↓
4. Architect: アプリケーションアーキテクチャ設計
   ↓
5. SRE: インフラアーキテクチャ設計
   ↓
6. PM: 両者の設計を統合し、整合性チェック
   ↓
7. PM → ユーザー: 設計内容の説明・確認
   ↓
8. PM: 基本設計書生成（docs/03_基本設計書.md）
```

**Architect への委譲例**:
```markdown
Task: 基本設計の作成

入力:
- 要件定義書: docs/02_要件定義書.md
- 技術標準: .claude/docs/40_standards/
- 設計方針: [PM がユーザーから確認した内容]

期待する出力:
1. システム構成図（Mermaid）
2. コンポーネント設計
3. データモデル設計
4. API設計
5. 技術選定の根拠
```

---

### 4. 実装フェーズ

**PM の役割**:
- 実装の優先順位決定
- Coder に実装を委譲
- SRE にデプロイスクリプト作成を委譲

**オーケストレーションフロー**:
```
1. PM: 実装の優先順位をユーザーと確認
   ↓
2. PM → Coder: 「この機能を実装して（技術標準準拠）」
   ↓
3. PM → SRE: 「デプロイスクリプトを作成して（Change Set必須）」（並行実行）
   ↓
4. Coder: コード実装（技術標準に準拠）
   ↓
5. SRE: デプロイスクリプト生成（create/describe/execute/rollback）
   ↓
6. PM: コードレビュー・品質チェック
   ↓
7. PM → ユーザー: 実装内容の説明
```

**Coder への委譲例**:
```markdown
Task: 機能実装

入力:
- 基本設計書: docs/03_基本設計書.md
- 実装対象: [具体的な機能名]
- 技術標準: .claude/docs/40_standards/42_typescript.md

期待する出力:
1. 実装コード（src/）
2. ユニットテスト（tests/）
3. コードの説明（なぜこう実装したか）

制約:
- 技術標準に厳格に準拠すること
- 事前説明→実装→事後説明の流れを守ること
```

**SRE への委譲例**:
```markdown
Task: デプロイスクリプト生成

入力:
- インフラ設計: docs/03_基本設計書.md（インフラ部分）
- デプロイ方式: CloudFormation

期待する出力（必須4スクリプト）:
1. scripts/create-changeset.sh（Change Set作成）
2. scripts/describe-changeset.sh（内容確認）
3. scripts/execute-changeset.sh（実行）
4. scripts/rollback.sh（ロールバック）

制約:
- 直接デプロイ（aws cloudformation deploy）は禁止
- エラーハンドリング必須
- dry-run必須
```

---

### 5. テストフェーズ

**PM の役割**:
- テスト計画の確認
- QA にテスト設計・実行を委譲
- テスト結果の評価

**オーケストレーションフロー**:
```
1. PM: ユーザーにテスト方針を確認
   ↓
2. PM → QA: 「テスト計画を作成して」
   ↓
3. QA: テスト計画・テストケース作成
   ↓
4. PM: テスト計画をユーザーに提示・承認
   ↓
5. PM → QA: 「テストを実行して」
   ↓
6. QA: テスト実行・結果レポート作成
   ↓
7. PM: 結果を評価し、問題があれば Coder に修正依頼
   ↓
8. PM → ユーザー: テスト結果報告
```

**QA への委譲例**:
```markdown
Task: テスト実行

入力:
- 要件定義書: docs/02_要件定義書.md
- 実装コード: src/
- テスト方針: [PM がユーザーから確認した内容]

期待する出力:
1. テスト計画書
2. テストケース一覧
3. テスト実行結果
4. 品質評価レポート

テスト種別:
- [ ] 統合テスト
- [ ] E2Eテスト
- [ ] 性能テスト
- [ ] セキュリティテスト
```

---

### 6. 納品フェーズ

**PM の役割**:
- 納品物の最終チェック
- SRE にデプロイ手順書作成を委譲
- 納品物の説明

**オーケストレーションフロー**:
```
1. PM: 納品物リストの作成
   ↓
2. PM → SRE: 「デプロイ手順書を作成して」
   ↓
3. SRE: デプロイ手順書・運用手順書作成
   ↓
4. PM: すべての成果物を最終チェック
   ↓
5. PM: README.md 生成
   ↓
6. PM → ユーザー: 納品物の説明・使い方ガイド
```

---

## 🎨 サブエージェント間の連携パターン

### パターン1: 順次実行

```
PM → Consultant（分析）→ PM → Architect（設計）→ PM
```

**使用場面**: 前の結果が次の入力になる場合

### パターン2: 並行実行

```
PM → Consultant（要件整理）
  └→ Architect（技術評価）
       ↓
      PM（統合）
```

**使用場面**: 独立したタスクを同時実行できる場合

### パターン3: フィードバックループ

```
PM → Coder（実装）→ PM → QA（テスト）
                        ↓ （バグ発見）
                     Coder（修正）→ PM → QA（再テスト）
```

**使用場面**: テストで問題が見つかった場合

### パターン4: クロスチェック（設計）

```
PM → Architect（設計）→ PM
  └→ SRE（レビュー）→ PM（統合・調整）
```

**使用場面**: 設計の品質を複数の視点で確認する場合

### パターン5: 専門家レビュー（実装前）

```
PM → Architect（詳細設計）
       ↓
      PM: 「この設計でCoderに実装依頼していい？」
       ↓
    Architect: 「OK」または「こう修正してください」
       ↓
      PM → Coder（実装）
```

**使用場面**: 実装に入る前に設計の最終確認が必要な場合

### パターン6: 技術レビュー（実装後）

```
PM → Coder（実装完了）
       ↓
      PM → Architect: 「設計通りに実装されているかレビューして」
       ↓
    Architect: コードレビュー
       ├─ 問題あり → PM → Coder（修正）
       └─ OK → PM → QA（テスト）
```

**使用場面**:
- 複雑な実装でアーキテクチャの整合性確認が必要
- 設計からの逸脱がないかチェック
- 技術標準準拠の確認

**レビュー観点**:
- 設計書との整合性
- アーキテクチャパターンの適用
- 技術標準への準拠
- パフォーマンス上の問題
- セキュリティ懸念

### パターン7: マルチレビュー

```
PM → Coder（実装完了）
       ↓
      PM → Architect（アーキテクチャレビュー）
        └→ SRE（デプロイ可能性レビュー）
        └→ QA（テスト可能性レビュー）
       ↓
      PM: 3者の意見を統合
       ├─ 問題あり → Coder（修正）
       └─ OK → 次フェーズ
```

**使用場面**: 重要な機能で多角的なレビューが必要な場合

---

## 📊 サブエージェントの責務マトリックス

| フェーズ | Consultant | Architect | Coder | QA | SRE |
|---------|-----------|-----------|-------|----|----|
| 企画 | ◎ | - | - | - | - |
| 要件定義 | ◎ | ○ | - | - | - |
| 設計 | ○ | ◎ | - | - | ◎ |
| 実装 | - | ○ | ◎ | - | ◎ |
| テスト | - | - | ○ | ◎ | ○ |
| 納品 | - | - | - | ○ | ◎ |

- ◎: 主担当
- ○: サポート・レビュー
- -: 関与なし

---

## 👥 フェーズ別の役割分担とレビュー体制

### 1. 企画フェーズ（上流工程）

**主担当**: PM + Consultant

**役割**:
- **PM**: ユーザーからビジネス課題をヒアリング、一問一答で深掘り
- **Consultant**: ビジネス課題の分析、As-Is/To-Be 分析、ROI 試算、解決策提案

**レビュー体制**:
- **Architect**: 技術的実現可能性の確認（オプション）
  - 「この予算・納期で実現できそうですか？」
  - 「技術的に大きなリスクはありますか？」
- **Presales（プリセールス）**: 商談段階の場合、提案内容のレビュー（オプション）

**成果物**: `docs/01_企画書.md`

**レビューフロー**:
```
PM → Consultant（分析・提案）
       ↓
      PM（内部レビュー）
       ↓
    [Architect]（技術リスク確認）← オプション
       ↓
    ユーザー（承認）
```

---

### 2. 要件定義フェーズ（上流工程）

**主担当**: PM + Consultant

**役割**:
- **PM**: 機能要件・非機能要件のヒアリング、優先順位付け
- **Consultant**: 要件の整理、漏れチェック、ユースケース作成

**レビュー体制**:
- **Architect**: 技術的実現可能性の評価
  - 「この性能要件は達成できますか？」
  - 「技術スタックの推奨は？」
- **PM**: Consultant と Architect の意見を統合

**成果物**: `docs/02_要件定義書.md`

**レビューフロー**:
```
PM → Consultant（要件整理）
       ↓
      PM（内部レビュー）
       ↓
    Architect（技術評価）
       ↓
      PM（統合）
       ↓
    ユーザー（承認）
```

---

### 3. 設計フェーズ

**主担当**: PM + Architect

**役割**:
- **PM**: 要件定義書を Architect に渡し、設計方針を合意
- **Architect**: システムアーキテクチャ設計、技術選定、API設計、データモデル設計

**レビュー体制**:
- **Coder**: 実装可能性の確認
  - 「この設計で実装できそうですか？」
  - 「実装時に困りそうな箇所はありますか？」
- **SRE**: インフラ設計・運用性のレビュー
  - 「このインフラ構成で運用できますか？」
  - 「監視・ログ設計は適切ですか？」
- **PM**: Architect, Coder, SRE の意見を統合

**成果物**: `docs/03_基本設計/` (13ファイル構成)

**レビューフロー**:
```
PM → Architect（設計）
       ↓
      PM（内部レビュー）
       ↓
    Coder（実装可能性確認）
       ↓
    SRE（運用性確認）
       ↓
      PM（統合）
       ↓
    ユーザー（承認）
```

---

### 4. 実装フェーズ

**主担当**: Coder

**役割**:
- **Coder**: コード実装、ユニットテスト、技術標準準拠

**レビュー体制**:
- **Architect**: 設計との整合性確認
  - 「設計書通りに実装されていますか？」
  - 「アーキテクチャパターンは適用されていますか？」
- **QA**: テスト観点の確認
  - 「テストしやすいコードになっていますか？」
  - 「境界値テストは考慮されていますか？」
- **SRE**: デプロイ可能性の確認
  - 「デプロイスクリプトは動きますか？」
  - 「環境変数は適切に分離されていますか？」

**成果物**: `src/`, `tests/`, `infra/`

**レビューフロー**:
```
PM → Coder（実装）
       ↓
    Architect（設計整合性レビュー）
       ↓
    QA（テスト観点レビュー）
       ↓
    SRE（デプロイ可能性レビュー）
       ↓
      PM（統合）
       ↓
    ユーザー（デモ・確認）
```

---

### 5. テストフェーズ

**主担当**: QA

**役割**:
- **QA**: テストケース作成、統合テスト、E2Eテスト、システムテスト、受け入れテスト

**レビュー体制**:
- **Architect**: 非機能要件達成の確認
  - 「性能要件は満たされていますか？」
  - 「可用性要件は達成できていますか？」
- **Coder**: バグ修正
  - QA がバグを発見 → Coder が修正 → QA が再テスト
- **SRE**: 性能テスト・負荷テストの実施と結果レビュー
  - 「本番相当の負荷でテストしました」
  - 「ボトルネックを特定しました」

**成果物**: テストケース、テスト結果レポート、バグレポート

**レビューフロー**:
```
PM → QA（テスト設計）
       ↓
    Architect（テスト設計レビュー）
       ↓
    QA（テスト実行）
       ├─ バグ発見 → Coder（修正）→ QA（再テスト）
       ↓
    SRE（性能テスト）
       ↓
    Architect（非機能要件達成確認）
       ↓
      PM（統合）
       ↓
    ユーザー（受け入れテスト）
```

---

### 6. 運用・納品フェーズ

**主担当**: SRE

**役割**:
- **SRE**: デプロイスクリプト作成、CloudFormation Change Sets、CI/CD構築、監視設定、運用手順書作成

**レビュー体制**:
- **Architect**: インフラ設計との整合性確認
  - 「設計書通りのインフラ構成ですか？」
  - 「セキュリティ要件は満たされていますか？」
- **QA**: デプロイテストの実施
  - 「本番環境へのデプロイは問題ありませんか？」
  - 「ロールバック手順は確認できていますか？」
- **Coder**: アプリケーション視点でのインフラ確認
  - 「環境変数は正しく設定されていますか？」
  - 「ログは適切に出力されていますか？」

**成果物**: `infra/cloudformation/`, デプロイ手順書、運用手順書、監視設定

**レビューフロー**:
```
PM → SRE（インフラ構築）
       ↓
    Architect（設計整合性レビュー）
       ↓
    QA（デプロイテスト）
       ↓
    Coder（アプリ視点確認）
       ↓
      PM（統合）
       ↓
    ユーザー（本番稼働承認）
```

---

### 横断的なレビュー原則

**全フェーズ共通**:
1. **PM 内部レビュー必須**: サブエージェントの成果物は必ず PM がレビュー
2. **段階的デリバリー**: ドラフト（60-70%） → 仮版（80-90%） → 最終版（100%）
3. **イテレーション**: NG なら修正依頼、OK ならユーザー確認
4. **ユーザー承認**: 最終的にユーザーが承認してから次フェーズへ

**専門家クロスレビュー**:
- 設計フェーズ: Architect ← Coder + SRE
- 実装フェーズ: Coder ← Architect + QA + SRE
- テストフェーズ: QA ← Architect + SRE
- 納品フェーズ: SRE ← Architect + QA

**レビュー文化**:
- 一方的に進めず、対話的に合意形成
- 透明性: 何をどうレビューしたか明示
- 学習機会: レビュー観点を共有

---

## 🔒 コンテキスト管理の原則

### PM のコンテキスト

**常に保持**:
- プロジェクト全体の状態（.claude-state/project-state.json）
- ユーザーとの会話履歴
- 全フェーズの成果物

**参照するドキュメント**:
- .claude/docs/10_facilitation/（フェーズガイド）
- .claude/docs/00_core-principles.md

### サブエージェントのコンテキスト

**最小限の情報のみ**:
- 自分のタスクに必要な入力情報
- 該当する技術標準（.claude/docs/40_standards/）

**メリット**:
- コンテキストの肥大化防止
- 処理速度の向上
- 専門性の確保

---

## 🚀 実装方針

### Phase 1: PM オーケストレーション機能追加

1. CLAUDE.md にオーケストレーションロジックを追加
2. サブエージェント呼び出しの判断ロジック実装
3. 結果の統合・品質チェックロジック実装

### Phase 2: サブエージェント作成

1. 各サブエージェントの AGENT.md 作成
2. 役割・責務の明確化
3. 入力・出力フォーマットの定義

### Phase 3: テスト・検証

1. 単純なプロジェクトでテスト
2. 各フェーズでの動作確認
3. Round 4 テストでの評価

---

## 📝 次のステップ

1. **5つのサブエージェント AGENT.md 作成**
   - consultant/AGENT.md
   - architect/AGENT.md
   - coder/AGENT.md
   - qa/AGENT.md
   - sre/AGENT.md

2. **CLAUDE.md のオーケストレーション実装**
   - サブエージェント呼び出しロジック
   - 結果統合ロジック
   - 品質チェックロジック

3. **テスト実行**
   - 簡単なプロジェクトで動作確認
   - Round 4 テストで評価

---

**作成者**: Claude（PM エージェント）
**レビュー状態**: Draft
**次のアクション**: 各サブエージェント AGENT.md の作成
