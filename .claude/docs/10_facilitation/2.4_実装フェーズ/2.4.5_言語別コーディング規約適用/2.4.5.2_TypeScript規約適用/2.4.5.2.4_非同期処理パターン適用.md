# 2.4.5.2.4 TypeScript非同期処理パターン適用

## 目的

TypeScriptのasync/awaitを正しく使用し、`.claude/docs/40_standards/42_typescript.md` に準拠した非同期処理を実装します。

---

## 🎯 async/awaitの基本

### 1. async関数の定義 ⭐⭐⭐

**原則**:
- ✅ 非同期処理を行う関数は `async` を付与
- ✅ 戻り値は `Promise<T>` 型
- ✅ エラーハンドリングは try-catch

**例**:

```typescript
// ✅ async関数の基本
async function getUser(userId: number): Promise<User> {
  const user = await db.query<User>('SELECT * FROM users WHERE id = $1', [userId]);
  return user;
}

// ✅ null許容
async function findUser(userId: number): Promise<User | null> {
  const user = await db.query<User>('SELECT * FROM users WHERE id = $1', [userId]);
  return user || null;
}
```

---

### 2. awaitの使用 ⭐⭐⭐

**原則**:
- ✅ Promiseを返す関数には `await` を使用
- ✅ awaitし忘れに注意
- ✅ 不要なawaitは避ける

**例**:

```typescript
// ✅ awaitを使用
async function processUser(userId: number): Promise<void> {
  const user = await getUser(userId);  // ✅ awaitを使用
  console.log(user.name);
}

// ❌ awaitし忘れ
async function processUserBad(userId: number): Promise<void> {
  const user = getUser(userId);  // ❌ Promise<User> が返る
  console.log(user.name);  // ❌ Promiseにnameプロパティはない
}
```

---

### 3. 並列処理 ⭐⭐

**原則**:
- ✅ 独立した非同期処理は並列実行
- ✅ `Promise.all()` を使用
- ✅ `Promise.allSettled()` でエラーを個別処理

**例**:

```typescript
// ✅ 並列実行（Promise.all）
async function getUsersParallel(userIds: number[]): Promise<User[]> {
  const promises = userIds.map(id => getUser(id));
  const users = await Promise.all(promises);  // ✅ 並列実行
  return users;
}

// ✅ エラーを個別処理（Promise.allSettled）
async function getUsersSafe(userIds: number[]): Promise<User[]> {
  const promises = userIds.map(id => getUser(id));
  const results = await Promise.allSettled(promises);

  return results
    .filter(result => result.status === 'fulfilled')
    .map(result => (result as PromiseFulfilledResult<User>).value);
}

// ❌ 直列実行（遅い）
async function getUsersSequential(userIds: number[]): Promise<User[]> {
  const users: User[] = [];
  for (const id of userIds) {
    const user = await getUser(id);  // ❌ 1つずつ実行（遅い）
    users.push(user);
  }
  return users;
}
```

---

## 📋 非同期処理パターン

### パターン1: 基本的なasync/await

```typescript
import { User } from '../models/user';
import { UserNotFoundError } from '../utils/errors';
import logger from '../utils/logger';

async function getUser(userId: number): Promise<User> {
  try {
    const user = await db.query<User>('SELECT * FROM users WHERE id = $1', [userId]);
    if (!user) {
      throw new UserNotFoundError(`User ${userId} not found`);
    }
    return user;
  } catch (error) {
    logger.error(`Failed to get user ${userId}:`, error);
    throw error;
  }
}
```

---

### パターン2: リトライ付き非同期処理

```typescript
async function fetchWithRetry<T>(
  fn: () => Promise<T>,
  maxRetries: number = 3,
  delay: number = 1000
): Promise<T> {
  let lastError: Error;

  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error as Error;
      logger.warn(`Attempt ${attempt} failed:`, error);

      if (attempt < maxRetries) {
        await new Promise(resolve => setTimeout(resolve, delay * attempt));
      }
    }
  }

  throw lastError!;
}

// 使用例
const user = await fetchWithRetry(() => getUser(1), 3, 1000);
```

---

### パターン3: タイムアウト付き非同期処理

```typescript
async function withTimeout<T>(
  promise: Promise<T>,
  timeoutMs: number
): Promise<T> {
  const timeoutPromise = new Promise<never>((_, reject) => {
    setTimeout(() => reject(new Error('Timeout')), timeoutMs);
  });

  return Promise.race([promise, timeoutPromise]);
}

// 使用例
try {
  const user = await withTimeout(getUser(1), 5000);  // 5秒でタイムアウト
} catch (error) {
  logger.error('Timeout or error:', error);
}
```

---

### パターン4: キュー処理

```typescript
class TaskQueue<T> {
  private queue: Array<() => Promise<T>> = [];
  private running = 0;

  constructor(private concurrency: number = 1) {}

  async add(task: () => Promise<T>): Promise<T> {
    return new Promise((resolve, reject) => {
      this.queue.push(async () => {
        try {
          const result = await task();
          resolve(result);
        } catch (error) {
          reject(error);
        }
      });
      this.process();
    });
  }

  private async process(): Promise<void> {
    if (this.running >= this.concurrency || this.queue.length === 0) {
      return;
    }

    this.running++;
    const task = this.queue.shift()!;

    try {
      await task();
    } finally {
      this.running--;
      this.process();
    }
  }
}

// 使用例
const queue = new TaskQueue<User>(2);  // 同時実行数2
const users = await Promise.all([
  queue.add(() => getUser(1)),
  queue.add(() => getUser(2)),
  queue.add(() => getUser(3)),
]);
```

---

### パターン5: Express/Fastifyでの非同期処理

```typescript
import { Router } from 'express';
import { UserService } from '../services/userService';

const router = Router();
const userService = new UserService();

// ✅ async/awaitを使用
router.get('/users/:id', async (req, res, next) => {
  try {
    const userId = parseInt(req.params.id);
    const user = await userService.getUser(userId);
    res.json(user);
  } catch (error) {
    next(error);  // ✅ エラーハンドラーに渡す
  }
});

// ✅ エラーハンドラー（最後に配置）
router.use((error: Error, req, res, next) => {
  logger.error('API error:', error);
  res.status(500).json({ error: error.message });
});

export default router;
```

---

## ❌ Bad Example: 非同期処理の誤用

```typescript
// ❌ awaitし忘れ
async function processUser(userId: number) {
  const user = getUser(userId);  // ❌ Promise<User>
  console.log(user.name);  // ❌ Error
}

// ❌ 直列実行（遅い）
async function getUsers(userIds: number[]) {
  const users = [];
  for (const id of userIds) {
    users.push(await getUser(id));  // ❌ 1つずつ実行
  }
  return users;
}

// ❌ エラーハンドリングなし
async function getUserBad(userId: number) {
  const user = await db.query(userId);  // ❌ try-catchなし
  return user;
}

// ❌ Promiseのネスト
function getUserNested(userId: number) {
  return getUser(userId).then(user => {
    return processUser(user).then(result => {
      return result;  // ❌ ネストが深い
    });
  });
}
```

**問題点**:
- awaitし忘れでバグ
- 直列実行で遅い
- エラーハンドリングなし
- コードが読みにくい

---

## ✅ Good Example: 適切な非同期処理

```typescript
// ✅ awaitを使用
async function processUser(userId: number): Promise<void> {
  const user = await getUser(userId);
  console.log(user.name);
}

// ✅ 並列実行
async function getUsers(userIds: number[]): Promise<User[]> {
  return Promise.all(userIds.map(id => getUser(id)));
}

// ✅ エラーハンドリング
async function getUser(userId: number): Promise<User> {
  try {
    const user = await db.query<User>('SELECT * FROM users WHERE id = $1', [userId]);
    if (!user) {
      throw new UserNotFoundError(`User ${userId} not found`);
    }
    return user;
  } catch (error) {
    logger.error(`Failed to get user ${userId}:`, error);
    throw error;
  }
}

// ✅ async/awaitでフラット
async function getUserAndProcess(userId: number): Promise<ProcessedUser> {
  const user = await getUser(userId);
  const processed = await processUser(user);
  return processed;
}
```

**改善点**:
- ✅ awaitを正しく使用
- ✅ 並列実行で高速化
- ✅ エラーハンドリング
- ✅ 読みやすいコード

---

## 🔍 非同期処理チェックリスト

コード生成前に確認：

1. [ ] 非同期処理を行う関数に `async` を付与
2. [ ] Promiseを返す関数に `await` を使用
3. [ ] 独立した非同期処理は `Promise.all()` で並列実行
4. [ ] エラーハンドリング（try-catch）
5. [ ] 戻り値の型は `Promise<T>`
6. [ ] 不要なawaitは避ける

---

**作成日**: 2025-10-19
**対象フェーズ**: 実装
**重要度**: ⭐⭐⭐ 必須
