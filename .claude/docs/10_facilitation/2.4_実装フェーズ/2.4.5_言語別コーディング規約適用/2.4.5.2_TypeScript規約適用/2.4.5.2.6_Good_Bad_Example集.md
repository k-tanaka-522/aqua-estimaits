# 2.4.5.2.6 TypeScript Good_Bad_Example集

## 目的

TypeScript実装のよくある間違いパターンと推奨パターンを示します。

---

## 🔄 実例パターン集

### 1. 型定義

#### ❌ Bad Example

```typescript
// ❌ any型を使用
function getUser(userId: any): any {
  return db.query(userId);
}

// ❌ 型定義なし
function processData(data) {
  return data.map(item => item.value);
}
```

**問題点**:
- 型安全性がない
- エディタの補完が効かない
- バグが混入しやすい

#### ✅ Good Example

```typescript
// ✅ interface による型定義
interface User {
  id: number;
  name: string;
  email: string;
}

function getUser(userId: number): Promise<User | null> {
  return db.query<User>('SELECT * FROM users WHERE id = $1', [userId]);
}

// ✅ ジェネリクスで型安全
function processData<T>(data: T[], key: keyof T): T[keyof T][] {
  return data.map(item => item[key]);
}
```

**改善点**:
- ✅ 型安全性
- ✅ エディタの補完が効く
- ✅ バグを未然に防ぐ

---

### 2. 非同期処理

#### ❌ Bad Example

```typescript
// ❌ awaitし忘れ
async function processUser(userId: number) {
  const user = getUser(userId);  // ❌ Promise<User>
  console.log(user.name);  // ❌ Error
}

// ❌ 直列実行（遅い）
async function getUsers(userIds: number[]) {
  const users = [];
  for (const id of userIds) {
    users.push(await getUser(id));  // ❌ 1つずつ実行
  }
  return users;
}
```

**問題点**:
- awaitし忘れでバグ
- 直列実行で遅い

#### ✅ Good Example

```typescript
// ✅ awaitを使用
async function processUser(userId: number): Promise<void> {
  const user = await getUser(userId);
  console.log(user.name);
}

// ✅ 並列実行
async function getUsers(userIds: number[]): Promise<User[]> {
  return Promise.all(userIds.map(id => getUser(id)));
}
```

**改善点**:
- ✅ awaitを正しく使用
- ✅ 並列実行で高速化

---

### 3. エラーハンドリング

#### ❌ Bad Example

```typescript
// ❌ try-catchなし
async function getUser(userId: number) {
  const user = await db.query(userId);
  return user;
}

// ❌ 汎用的なError
if (!user) {
  throw new Error('Error');  // ❌ 何のエラーか不明
}
```

**問題点**:
- エラー処理がない
- エラーメッセージが不明瞭

#### ✅ Good Example

```typescript
// ✅ カスタムエラークラス
class UserNotFoundError extends Error {
  constructor(public userId: number) {
    super(`User ${userId} not found`);
    this.name = 'UserNotFoundError';
  }
}

// ✅ try-catch + カスタムエラー
async function getUser(userId: number): Promise<User> {
  try {
    const user = await db.query<User>('SELECT * FROM users WHERE id = $1', [userId]);
    if (!user) {
      throw new UserNotFoundError(userId);
    }
    return user;
  } catch (error) {
    logger.error(`Failed to get user ${userId}:`, error);
    throw error;
  }
}
```

**改善点**:
- ✅ カスタムエラーで意図が明確
- ✅ ログ出力
- ✅ try-catchでエラー処理

---

### 4. Null/Undefined チェック

#### ❌ Bad Example

```typescript
// ❌ nullチェックなし
function getUserName(user: User | null): string {
  return user.name;  // ❌ Error: Object is possibly 'null'
}

// ❌ 型アサーション乱用
function getUserName2(user: User | null): string {
  return (user as User).name;  // ❌ 危険
}
```

**問題点**:
- Null参照エラー
- 型アサーションで型安全性を無視

#### ✅ Good Example

```typescript
// ✅ nullチェック
function getUserName(user: User | null): string | null {
  if (!user) {
    return null;
  }
  return user.name;
}

// ✅ Optional Chaining
function getUserEmail(user: User | null): string | undefined {
  return user?.email;
}

// ✅ Nullish Coalescing
function getUserNameOrDefault(user: User | null): string {
  return user?.name ?? 'Unknown';
}
```

**改善点**:
- ✅ null/undefinedを安全に処理
- ✅ Optional Chaining/Nullish Coalescing を活用

---

### 5. 型アサーション

#### ❌ Bad Example

```typescript
// ❌ as any で型安全性を無視
const data = JSON.parse(jsonString) as any;
console.log(data.name);  // ❌ 型チェックなし

// ❌ 危険な型アサーション
const user = {} as User;  // ❌ 空オブジェクトをUserとして扱う
console.log(user.name);  // undefined
```

**問題点**:
- 型安全性を無視
- ランタイムエラーのリスク

#### ✅ Good Example

```typescript
// ✅ 型ガードを使用
interface User {
  id: number;
  name: string;
  email: string;
}

function isUser(obj: unknown): obj is User {
  return (
    typeof obj === 'object' &&
    obj !== null &&
    'id' in obj &&
    typeof obj.id === 'number' &&
    'name' in obj &&
    typeof obj.name === 'string'
  );
}

const data = JSON.parse(jsonString);
if (isUser(data)) {
  console.log(data.name);  // ✅ 型安全
}

// ✅ Zodなどのバリデーションライブラリ
import { z } from 'zod';

const UserSchema = z.object({
  id: z.number(),
  name: z.string(),
  email: z.string().email(),
});

const user = UserSchema.parse(JSON.parse(jsonString));  // ✅ 型安全
```

**改善点**:
- ✅ 型ガードで安全に型を確認
- ✅ バリデーションライブラリで型安全性を保証

---

### 6. 環境変数・設定管理

#### ❌ Bad Example

```typescript
// ❌ ハードコード
const DATABASE_URL = 'postgresql://user:password@localhost/db';

// ❌ 型チェックなし
const PORT = process.env.PORT;  // string | undefined
app.listen(PORT);  // ❌ Error
```

**問題点**:
- シークレットがハードコード
- 環境変数の型が不明

#### ✅ Good Example

```typescript
// ✅ 環境変数を使用 + 型安全
import dotenv from 'dotenv';
dotenv.config();

function getEnv(key: string): string {
  const value = process.env[key];
  if (!value) {
    throw new Error(`Environment variable ${key} is not set`);
  }
  return value;
}

const DATABASE_URL = getEnv('DATABASE_URL');
const PORT = parseInt(getEnv('PORT'), 10);

app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});
```

**改善点**:
- ✅ 環境変数を使用
- ✅ 型安全性を確保
- ✅ 未設定時にエラー

---

### 7. テスト

#### ❌ Bad Example

```typescript
// ❌ AAAパターンなし
test('get user', async () => {
  const result = await service.getUser(1);
  expect(result.name).toBe('Test');
});

// ❌ モックなし
test('get user', async () => {
  const service = new UserService();
  const result = await service.getUser(1);  // ❌ 実DB
  expect(result).toBeTruthy();
});
```

**問題点**:
- 可読性が低い
- テストが遅い

#### ✅ Good Example

```typescript
import { UserService } from '../src/services/userService';
import { UserRepository } from '../src/repositories/userRepository';

jest.mock('../src/repositories/userRepository');

describe('UserService', () => {
  let userService: UserService;
  let mockUserRepository: jest.Mocked<UserRepository>;

  beforeEach(() => {
    mockUserRepository = new UserRepository() as jest.Mocked<UserRepository>;
    userService = new UserService(mockUserRepository);
  });

  test('should return user when user exists', async () => {
    // Arrange
    const mockUser = { id: 1, name: 'Test', email: 'test@example.com' };
    mockUserRepository.findById.mockResolvedValue(mockUser);

    // Act
    const result = await userService.getUser(1);

    // Assert
    expect(result).toEqual(mockUser);
  });
});
```

**改善点**:
- ✅ AAAパターン
- ✅ モック使用（高速）

---

### 8. 依存性注入

#### ❌ Bad Example

```typescript
// ❌ ハードコードされた依存関係
class UserService {
  private repository = new UserRepository();  // ❌ ハードコード

  async getUser(userId: number) {
    return this.repository.findById(userId);
  }
}
```

**問題点**:
- テストが困難
- モックできない

#### ✅ Good Example

```typescript
// ✅ 依存性注入
class UserService {
  constructor(private repository: UserRepository) {}

  async getUser(userId: number): Promise<User> {
    return this.repository.findById(userId);
  }
}

// テスト時にモックを注入可能
const mockRepo = new UserRepository() as jest.Mocked<UserRepository>;
const service = new UserService(mockRepo);
```

**改善点**:
- ✅ テスト容易
- ✅ モック可能

---

## 📝 まとめ

### 必ず守るべきこと ⭐⭐⭐

1. **型定義**: any型を避け、interfaceやtypeを使用
2. **async/await**: 非同期処理は async/await、並列処理は Promise.all
3. **エラーハンドリング**: try-catch + カスタムエラークラス
4. **Null/Undefined**: Optional Chaining、Nullish Coalescing を活用
5. **環境変数**: ハードコードせず、環境変数を使用
6. **テスト**: AAAパターン、モック使用、カバレッジ80%以上

---

**作成日**: 2025-10-19
**対象フェーズ**: 実装
**重要度**: ⭐⭐⭐ 必須
