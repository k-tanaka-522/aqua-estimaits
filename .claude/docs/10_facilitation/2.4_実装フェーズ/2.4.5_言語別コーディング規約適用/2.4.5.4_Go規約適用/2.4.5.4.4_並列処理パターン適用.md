# 2.4.5.4.4 Go並列処理パターン適用

## 目的

Goのgoroutineとchannelを使った並列処理を実装します。

---

## 🔄 並列処理パターン

### 1. 基本的なgoroutine ⭐⭐⭐

```go
// ✅ Good Example
func ProcessUsers(ids []int) {
    var wg sync.WaitGroup

    for _, id := range ids {
        wg.Add(1)
        go func(userID int) {
            defer wg.Done()
            processUser(userID)
        }(id)  // ✅ idを引数で渡す
    }

    wg.Wait()
}

// ❌ Bad Example
for _, id := range ids {
    go func() {
        processUser(id)  // ❌ ループ変数をキャプチャ
    }()
}
```

---

### 2. channelによる通信 ⭐⭐

```go
func FetchUsers(ids []int) []*User {
    results := make(chan *User, len(ids))

    for _, id := range ids {
        go func(userID int) {
            user, err := GetUser(userID)
            if err == nil {
                results <- user
            }
        }(id)
    }

    users := make([]*User, 0, len(ids))
    for i := 0; i < len(ids); i++ {
        users = append(users, <-results)
    }

    return users
}
```

---

### 3. context によるキャンセル ⭐⭐⭐

```go
import "context"

func ProcessWithTimeout(ctx context.Context, id int) error {
    ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
    defer cancel()

    done := make(chan error)

    go func() {
        done <- processUser(id)
    }()

    select {
    case err := <-done:
        return err
    case <-ctx.Done():
        return ctx.Err()  // タイムアウト or キャンセル
    }
}
```

---

**作成日**: 2025-10-19
**対象フェーズ**: 実装
**重要度**: ⭐⭐⭐ 必須
