# 2.4.6.1.7 デプロイ自動化設計

## 目的

CloudFormation のデプロイ自動化スクリプト設計において、**背景・選定理由・トレードオフ**を設計書に記載するためのガイドです。

**重要**: 単に「スクリプトを作った」ではなく、「なぜこの設計にしたのか」を説明できるようにします。

---

## 📋 デプロイ自動化で決定すべきこと

### 1. スクリプト種類の選定

**基本スクリプト（責務分離）:**

| スクリプト | 目的 | 必須度 |
|-----------|------|--------|
| `create-changeset.sh` | Change Set作成のみ | ⭐⭐⭐ 必須 |
| `describe-changeset.sh` | Change Set詳細表示（dry-run） | ⭐⭐⭐ 必須 |
| `execute-changeset.sh` | Change Set実行のみ | ⭐⭐⭐ 必須 |
| `deploy.sh` | 上記3つを順番に実行（オーケストレーション） | ⭐⭐⭐ 必須 |
| `validate.sh` | テンプレート検証 | ⭐⭐ 推奨 |
| `rollback.sh` | ロールバック | ⭐⭐ 推奨 |

**追加スクリプト（規模・用途による）:**

| スクリプト | 目的 | 必須度 |
|-----------|------|--------|
| `deploy-all.sh` | 全スタック一括デプロイ（依存関係順） | ⭐ オプション |
| `import-resources.sh` | 手動設定のリソースインポート | ⭐ オプション |
| `save-changeset-log.sh` | Change Set監査ログ保存（S3） | ⭐ オプション |

**責務分離の利点:**
- ✅ CI/CDパイプラインで段階的に実行可能
- ✅ Change Set作成と実行の間に手動承認フローを挟める
- ✅ dry-run（Change Set確認のみ）が簡単
- ✅ テスト・デバッグがしやすい

### 2. Change Sets運用方針

**選択肢:**

| 方針 | メリット | デメリット | 適用ケース |
|------|---------|-----------|-----------|
| **Change Sets必須** | 本番事故防止 | 手順が増える | 本番環境、重要なリソース |
| **直接デプロイ** | 手順が簡単 | 誤操作リスク高 | 検証環境のみ |

### 3. 環境別の承認フロー

**選択肢:**

| 環境 | 承認フロー | 理由 |
|------|-----------|------|
| dev | 自動実行（承認なし） | 開発速度優先 |
| stg | 自動実行（承認なし） | 検証効率優先 |
| prd | 手動承認必須 | 本番事故防止 |

### 4. スタック依存関係の制御

**選択肢:**

| 方針 | メリット | デメリット | 適用ケース |
|------|---------|-----------|-----------|
| **手動実行** | シンプル | 順序ミスの可能性 | 小規模（スタック3個以下） |
| **deploy-all.sh** | 順序保証 | スクリプト複雑化 | 中規模以上（スタック4個以上） |

### 5. CI/CD統合時の追加考慮事項

**必須の追加機能:**

| 機能 | 目的 | 実装方法 | 必須度 |
|------|------|---------|--------|
| **dry-run自動実行** | Pull Request時に変更内容確認 | GitHub Actions で `diff.sh` 実行 | ⭐⭐⭐ 必須 |
| **自動ロールバック** | デプロイ失敗時に前バージョンに戻す | `rollback.sh` を自動実行 | ⭐⭐⭐ 必須 |
| **Change Set監査ログ** | 誰が何を変更したか記録 | S3にChange Set詳細を保存 | ⭐⭐ 推奨 |
| **手動設定のインポート** | コンソールで手動作成したリソースをIaC管理下に | `import-resources.sh` | ⭐ オプション |
| **並列デプロイ** | 依存関係がないスタックを並列実行 | `deploy-parallel.sh` | ⭐ オプション |
| **タイムアウト設定** | 長時間待機の防止 | `aws cloudformation wait --timeout` | ⭐⭐ 推奨 |

---

## 📝 設計書への記載例

### 詳細設計書「デプロイ自動化設計」セクション

```markdown
### 12.3 デプロイ自動化設計

#### 12.3.1 選定したスクリプト構成

**必須スクリプト:**
- `deploy.sh` - デプロイ自動化（Change Sets必須）
- `diff.sh` - dry-run専用（Change Set確認のみ）
- `validate.sh` - テンプレート検証
- `rollback.sh` - ロールバック

**任意スクリプト:**
- `deploy-all.sh` - 全スタック一括デプロイ（今回は**不採用**）

#### 12.3.2 選定理由

**要件定義書との紐付け:**
- 要件定義書 3.2.1節「本番環境への誤操作防止」
- 要件定義書 3.2.2節「変更内容の事前確認」

**技術的根拠:**
- Change Sets必須により、本番環境への誤操作を防止
- dry-run専用スクリプト（diff.sh）で、実行前に変更内容を確認可能
- 環境別に承認フローを変更（dev: 自動、prd: 手動承認）

#### 12.3.3 検討した代替案

| 方式 | メリット | デメリット | 不採用理由 |
|------|---------|-----------|-----------|
| **AWS CLI直接実行** | ・シンプル<br>・学習コスト低 | ・Change Sets忘れのリスク<br>・手順書必須 | 本番事故リスクが高い |
| **AWS CDK** | ・プログラミング言語で記述<br>・テスト可能 | ・学習コスト高<br>・ビルドステップ必要 | チームのスキルセット的に困難 |
| **Terraform** | ・マルチクラウド<br>・State管理が強力 | ・AWS固有機能が使いにくい<br>・移行コスト高 | 要件定義書 4.2.1節 でCloudFormation選定済み |
| **deploy-all.sh** | ・順序保証<br>・1コマンドで完結 | ・スクリプト複雑化<br>・デバッグ困難 | スタック数が3個で小規模なため不要 |

#### 12.3.4 トレードオフ

**メリット:**
- ✅ Change Sets必須で本番事故リスクを最小化
- ✅ dry-run専用スクリプトで変更内容を事前確認可能
- ✅ 環境別の承認フロー（dev自動、prd手動）で開発速度と安全性を両立
- ✅ シェルスクリプトで追加依存なし（AWS CLIのみ）

**デメリット:**
- ❌ Change Sets作成→確認→実行の3ステップが必要（手間増加）
- ❌ スタック依存関係は手動管理（network → storage → compute）
- ❌ シェルスクリプトのため型チェックなし（テストが困難）

**判断:**
本番環境の安全性を最優先し、Change Sets必須の設計を採用。
スタック数が3個と小規模なため、依存関係は手動管理で十分と判断。

**将来的な拡張の可能性:**
- スタック数が10個以上になった場合、`deploy-all.sh` を追加検討
- CI/CDパイプライン統合時は、GitHub Actions でスクリプトを呼び出す
```

---

## 🎯 判断基準

### スクリプト種類の判断

```
プロジェクト規模は？
  ↓
├─ 小規模（スタック3個以下）
│   → deploy.sh, diff.sh, validate.sh のみ
│   → deploy-all.sh は不要（手動管理で十分）
│
├─ 中規模（スタック4-10個）
│   → deploy.sh, diff.sh, validate.sh, deploy-all.sh
│   → 依存関係の順序制御が必要
│
└─ 大規模（スタック11個以上）
    → CI/CDパイプライン統合必須
    → GitHub Actions / GitLab CI で自動化
```

### Change Sets運用方針の判断

```
環境は？
  ↓
├─ dev, stg
│   → Change Sets作成・確認後、自動実行（承認不要）
│
└─ prd
    → Change Sets作成・確認後、手動承認必須
    → スクリプト内で read -p で承認プロンプト表示
```

---

## ✅ Good Example

### 例1: 小規模プロジェクト（スタック3個）

**設計書に記載:**

```markdown
#### 12.3.1 選定したスクリプト構成

**必須スクリプト:**
- `deploy.sh` - デプロイ自動化
- `diff.sh` - dry-run専用
- `validate.sh` - テンプレート検証

**不採用:**
- `deploy-all.sh` - スタック数3個と小規模なため、手動管理で十分

#### 12.3.2 選定理由

**プロジェクト規模:**
- スタック数: 3個（network, storage, compute）
- 依存関係: network → storage → compute（シンプル）

**技術的根拠:**
- スタック数が3個と小規模なため、依存関係は手動管理で十分
- `deploy-all.sh` は将来的にスタック数が10個以上になった場合に検討

#### 12.3.3 検討した代替案

| 方式 | メリット | デメリット | 不採用理由 |
|------|---------|-----------|-----------|
| **deploy-all.sh** | ・順序保証<br>・1コマンドで完結 | ・スクリプト複雑化<br>・デバッグ困難 | スタック数3個で小規模なため不要 |
```

**実装:**

```bash
# scripts/deploy.sh
#!/bin/bash
set -euo pipefail

ENVIRONMENT=$1
STACK_TYPE=$2

# (省略: Change Sets作成・確認・実行)

# 本番環境のみ承認プロンプト
if [ "$ENVIRONMENT" = "prd" ]; then
  read -p "Execute this Change Set? (yes/no): " CONFIRM
  if [ "$CONFIRM" != "yes" ]; then
    echo "Deployment cancelled."
    exit 0
  fi
fi
```

**判定:** ✅ 設計背景が明確、スクリプトもシンプル

---

### 例2: 中規模プロジェクト（スタック7個）

**設計書に記載:**

```markdown
#### 12.3.1 選定したスクリプト構成

**必須スクリプト:**
- `deploy.sh` - デプロイ自動化
- `diff.sh` - dry-run専用
- `validate.sh` - テンプレート検証
- `deploy-all.sh` - 全スタック一括デプロイ（依存関係順序制御）

#### 12.3.2 選定理由

**プロジェクト規模:**
- スタック数: 7個（network, storage, compute, monitoring, security, logging, backup）
- 依存関係: 複雑（network → storage → compute → monitoring, security は全てに依存）

**技術的根拠:**
- スタック数7個で中規模、手動管理では順序ミスのリスク高
- `deploy-all.sh` で依存関係を明示的に制御
- 各スタック間の待機時間も自動化

#### 12.3.3 検討した代替案

| 方式 | メリット | デメリット | 不採用理由 |
|------|---------|-----------|-----------|
| **手動実行** | ・シンプル | ・順序ミスの可能性 | スタック数7個で手動管理は困難 |
| **CI/CDパイプライン** | ・完全自動化<br>・監査ログ | ・初期構築コスト高 | 現時点では過剰、将来的に検討 |
```

**実装:**

```bash
# scripts/deploy-all.sh
#!/bin/bash
set -euo pipefail

ENVIRONMENT=$1

echo "Deploying all stacks in order..."

# 1. Network Stack（他のスタックが依存）
./scripts/deploy.sh ${ENVIRONMENT} network

# 2. Storage Stack（Network Stackに依存）
./scripts/deploy.sh ${ENVIRONMENT} storage

# 3. Compute Stack（Network, Storage Stackに依存）
./scripts/deploy.sh ${ENVIRONMENT} compute

# 4. Monitoring Stack（Compute Stackに依存）
./scripts/deploy.sh ${ENVIRONMENT} monitoring

# 5. Security Stack（全てのスタックに依存）
./scripts/deploy.sh ${ENVIRONMENT} security

# 6. Logging Stack（全てのスタックに依存）
./scripts/deploy.sh ${ENVIRONMENT} logging

# 7. Backup Stack（Storage, Compute Stackに依存）
./scripts/deploy.sh ${ENVIRONMENT} backup

echo "✅ All stacks deployed successfully"
```

**判定:** ✅ スタック数7個で依存関係が複雑なため、deploy-all.sh が必要

---

## ❌ Bad Example

### 例: 設計背景なし、スクリプトだけ作成

**設計書に記載なし:**
```
（デプロイ自動化に関する記載なし）
```

**実装:**
```bash
# scripts/deploy.sh
# （スクリプトだけ存在）
```

**問題点:**
- ❌ なぜこのスクリプト構成にしたのか不明
- ❌ deploy-all.sh を作らなかった理由が説明できない
- ❌ 本番環境の承認フローがない（事故リスク高）
- ❌ 代替案の検討がない（AWS CDK, Terraform を検討したか？）

---

## 🎯 設計書チェックリスト

デプロイ自動化設計を設計書に記載する際、以下をチェックしてください：

### 必須項目

- [ ] **12.3.1 選定したスクリプト構成**
  - [ ] 必須スクリプトのリスト
  - [ ] 任意スクリプトの採用/不採用理由

- [ ] **12.3.2 選定理由**
  - [ ] 要件定義書との紐付け（○○節）
  - [ ] 技術的根拠（Change Sets必須、環境別承認フロー）
  - [ ] プロジェクト規模（スタック数、依存関係の複雑さ）

- [ ] **12.3.3 検討した代替案**
  - [ ] AWS CLI直接実行
  - [ ] AWS CDK
  - [ ] Terraform
  - [ ] deploy-all.sh（採用/不採用理由）

- [ ] **12.3.4 トレードオフ**
  - [ ] メリット（Change Sets必須、環境別承認フロー）
  - [ ] デメリット（手順増加、手動管理）
  - [ ] 判断（安全性優先、将来的な拡張の可能性）

### オプション項目

- [ ] **12.3.5 CI/CDパイプライン統合**（将来的な拡張）
  - [ ] GitHub Actions / GitLab CI の例
  - [ ] 監査ログの記録方針

---

## 📚 参考資料

### 技術標準
- `.claude/docs/40_standards/45_cloudformation.md` - デプロイ自動化の実装例

### 関連プロセス
- `2.4.6.1.4_Change_Sets運用フロー.md` - Change Sets の運用方針
- `2.4.6.1.5_dry-run必須手順.md` - dry-run の実施手順

---

**作成日**: 2025-10-24
**対象フェーズ**: 実装
**重要度**: ⭐⭐⭐ 必須
