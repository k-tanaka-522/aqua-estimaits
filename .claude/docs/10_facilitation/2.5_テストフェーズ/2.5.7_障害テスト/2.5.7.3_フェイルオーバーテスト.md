# 2.5.7.3 フェイルオーバーテスト

## 目的

システムの冗長構成が正しく機能することを検証します。

---

## 🔄 フェイルオーバーテストの種類

### 1. データベースフェイルオーバー

#### RDS Multi-AZ

**構成**:
```
Primary DB (AZ-1a) → Standby DB (AZ-1b)
```

**テスト手順**:

```bash
# 1. プライマリDBのフェイルオーバー実行
aws rds failover-db-cluster \
  --db-cluster-identifier myapp-cluster

# 2. フェイルオーバー状況確認
aws rds describe-db-clusters \
  --db-cluster-identifier myapp-cluster \
  --query 'DBClusters[0].Status'

# 3. 新しいプライマリDBの確認
aws rds describe-db-cluster-endpoints \
  --db-cluster-identifier myapp-cluster
```

**監視スクリプト（Python）**:

```python
import time
import psycopg2
from datetime import datetime

def test_db_failover():
    start_time = datetime.now()
    errors = []

    for i in range(120):  # 2分間監視
        try:
            conn = psycopg2.connect(
                host="myapp-cluster.cluster-xxxx.ap-northeast-1.rds.amazonaws.com",
                database="myapp",
                user="admin",
                password="password",
                connect_timeout=5
            )
            cursor = conn.cursor()
            cursor.execute("SELECT 1")
            result = cursor.fetchone()
            print(f"[{i}] Connection OK: {result}")
            conn.close()
        except Exception as e:
            errors.append((datetime.now(), str(e)))
            print(f"[{i}] ERROR: {e}")

        time.sleep(1)

    end_time = datetime.now()
    downtime = sum(1 for _ in errors)

    print(f"\n=== フェイルオーバーテスト結果 ===")
    print(f"総時間: {(end_time - start_time).total_seconds()}秒")
    print(f"ダウンタイム: {downtime}秒")
    print(f"エラー率: {downtime / 120 * 100:.2f}%")

    return downtime < 60  # 目標: 60秒以内
```

---

### 2. アプリケーションサーバーフェイルオーバー

#### ECS タスクのフェイルオーバー

**構成**:
```
ALB → ECS Service (タスク: 3台)
```

**テスト手順**:

```bash
# 1. 現在のタスク確認
aws ecs list-tasks --cluster myapp-cluster --service-name myapp-service

# 2. タスクを1つ強制停止
aws ecs stop-task \
  --cluster myapp-cluster \
  --task arn:aws:ecs:ap-northeast-1:123456789012:task/myapp-cluster/abc123

# 3. ヘルスチェック・新タスク起動を監視
watch -n 2 "aws ecs describe-services \
  --cluster myapp-cluster \
  --services myapp-service \
  --query 'services[0].{Running:runningCount,Desired:desiredCount}'"
```

**k6負荷テスト（フェイルオーバー中）**:

```javascript
import http from 'k6/http';
import { check, sleep } from 'k6';

export let options = {
  vus: 100,
  duration: '5m',
  thresholds: {
    http_req_failed: ['rate<0.01'],  // エラー率1%未満
  },
};

export default function () {
  const res = http.get('https://api.example.com/health');
  check(res, {
    'status is 200': (r) => r.status === 200,
  });
  sleep(1);
}
```

**期待される結果**:
- ✅ ALBがヘルスチェックで障害検知（30秒以内）
- ✅ トラフィックが正常タスクに振り分けられる
- ✅ 新しいタスクが自動起動（1分以内）
- ✅ エラー率 < 1%

---

### 3. AZフェイルオーバー

#### Multi-AZ構成

**構成**:
```
AZ-1a: ALB + ECS (タスク2台)
AZ-1b: ALB + ECS (タスク2台)
AZ-1c: ALB + ECS (タスク2台)
```

**テスト（AWS FIS）**:

```yaml
ExperimentTemplate:
  Description: "AZ-1aのすべてのECSタスクを停止"
  Targets:
    AZ1aTasks:
      ResourceType: aws:ecs:task
      ResourceArns:
        - arn:aws:ecs:ap-northeast-1:...:task/myapp-cluster/*
      Filters:
        - Path: AvailabilityZone
          Values:
            - ap-northeast-1a
  Actions:
    StopTasks:
      ActionId: aws:ecs:stop-task
      Targets:
        Tasks: AZ1aTasks
```

実行:
```bash
aws fis start-experiment --experiment-template-id EXT1234567890
```

**期待される結果**:
- ✅ AZ-1bとAZ-1cのタスクが継続稼働
- ✅ エラー率 < 0.1%
- ✅ AZ-1aのタスクが再起動（3分以内）

---

### 4. リードレプリカフェイルオーバー

#### 構成

```
Primary DB (Write)
  ↓
Read Replica 1 (Read)
Read Replica 2 (Read)
```

**テスト**:

```bash
# Read Replica 1を停止
aws rds stop-db-instance --db-instance-identifier myapp-replica-1

# アプリケーションの動作確認
```

**アプリケーション側のフェイルオーバー処理**:

```python
from sqlalchemy import create_engine
from sqlalchemy.pool import NullPool

# リードレプリカのエンドポイント
READ_REPLICAS = [
    "myapp-replica-1.xxxx.ap-northeast-1.rds.amazonaws.com",
    "myapp-replica-2.xxxx.ap-northeast-1.rds.amazonaws.com",
]

class ReplicaPool:
    def __init__(self):
        self.engines = [
            create_engine(f"postgresql://user:pass@{host}/myapp", poolclass=NullPool)
            for host in READ_REPLICAS
        ]
        self.current_index = 0

    def get_engine(self):
        """ラウンドロビンでレプリカを選択"""
        for attempt in range(len(self.engines)):
            engine = self.engines[self.current_index]
            self.current_index = (self.current_index + 1) % len(self.engines)

            try:
                # 接続テスト
                with engine.connect() as conn:
                    conn.execute("SELECT 1")
                return engine
            except Exception as e:
                print(f"Replica {attempt} failed: {e}")
                continue

        raise Exception("All replicas are down")

# 使用例
pool = ReplicaPool()
engine = pool.get_engine()
```

---

## 🎯 フェイルオーバー目標値

| 項目 | 目標 |
|------|------|
| RDS フェイルオーバー時間 | < 60秒 |
| ECS タスク再起動時間 | < 90秒 |
| フェイルオーバー中のエラー率 | < 1% |
| データロス | 0件 |

---

## 📊 フェイルオーバーテスト結果サンプル

```markdown
# フェイルオーバーテスト結果

## テスト日時
2025-10-19 10:00:00

## テスト内容
RDS Multi-AZ フェイルオーバー

## 結果
- フェイルオーバー開始: 10:00:00
- プライマリ切り替え完了: 10:00:42 (42秒) ✅
- アプリケーションエラー回数: 3回
- エラー率: 0.03% ✅
- データロス: 0件 ✅

## 観測事項
- 42秒間、接続エラーが発生
- リトライ処理により、ユーザーへの影響は最小限
- 新プライマリDBへの接続は正常

## 改善点
- 接続タイムアウトを3秒→5秒に延長し、リトライ成功率を向上
```

---

**作成日**: 2025-10-19
**重要度**: ⭐⭐⭐
