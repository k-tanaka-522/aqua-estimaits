# 2.5.7.2 Chaos Engineeringパターン

## 目的

Chaos Engineeringの原則に基づき、システムの回復力を検証します。

---

## 🌪️ Chaos Engineeringの原則

### 1. 定常状態の仮説を立てる

**例**:
```
通常時の定常状態:
- レスポンスタイム（p95）: 200ms以下
- エラー率: 0.1%以下
- スループット: 1,000 req/s以上
```

### 2. 現実世界の事象をシミュレート

- サーバークラッシュ
- ネットワーク分断
- リソース枯渇
- 外部依存の障害

### 3. 本番環境で実行

- ステージング環境だけでなく、本番環境でも実施
- 小規模から開始（カナリアテスト）

### 4. 自動化

- CI/CDパイプラインに組み込む
- 定期的に実行（週次、月次）

---

## 🧪 Chaos Engineeringパターン

### パターン1: ランダムインスタンス停止

**目的**: オートスケーリング・ロードバランサーの動作確認

```yaml
# AWS FIS
ExperimentTemplate:
  Description: "ECSタスクをランダムに停止"
  Actions:
    StopRandomTask:
      ActionId: aws:ecs:stop-task
      Parameters:
        cluster: myapp-cluster
      Targets:
        Tasks:
          ResourceType: aws:ecs:task
          SelectionMode: PERCENT(10)  # 10%のタスクを停止
  StopConditions:
    - Source: aws:cloudwatch:alarm
      Value: !GetAtt HighErrorRateAlarm.Arn
```

**検証**:
```bash
# 障害注入前
curl -X POST https://api.example.com/chaos/start-stop-task

# モニタリング
watch -n 1 "aws ecs describe-services --cluster myapp-cluster --services myapp-service | jq '.services[0].runningCount'"

# k6で負荷をかけながら監視
k6 run --vus 100 --duration 5m load-test.js
```

---

### パターン2: レイテンシ注入

**目的**: タイムアウト・リトライ処理の検証

```yaml
# Chaos Mesh (Kubernetes)
apiVersion: chaos-mesh.org/v1alpha1
kind: NetworkChaos
metadata:
  name: network-delay-test
spec:
  action: delay
  mode: one
  selector:
    namespaces:
      - default
    labelSelectors:
      app: myapp
  delay:
    latency: "500ms"
    correlation: "100"
  duration: "5m"
```

**検証コード（Python）**:
```python
import httpx
import asyncio

async def test_with_latency():
    timeout = httpx.Timeout(2.0, connect=5.0)  # タイムアウト設定
    async with httpx.AsyncClient(timeout=timeout) as client:
        try:
            response = await client.get("http://api.example.com/users")
            print(f"Success: {response.status_code}")
        except httpx.TimeoutException:
            print("Timeout occurred - handled correctly")
```

---

### パターン3: CPUスパイク

**目的**: リソース枯渇時の動作確認

```yaml
# Chaos Mesh
apiVersion: chaos-mesh.org/v1alpha1
kind: StressChaos
metadata:
  name: cpu-stress-test
spec:
  mode: one
  selector:
    namespaces:
      - default
    labelSelectors:
      app: myapp
  stressors:
    cpu:
      workers: 4
      load: 100  # 100% CPU
  duration: '2m'
```

**検証項目**:
- ✅ アプリケーションがクラッシュしないか
- ✅ CloudWatchアラームが発火するか
- ✅ オートスケーリングが発動するか

---

### パターン4: メモリ枯渇

```yaml
# Chaos Mesh
apiVersion: chaos-mesh.org/v1alpha1
kind: StressChaos
metadata:
  name: memory-stress-test
spec:
  mode: one
  selector:
    namespaces:
      - default
    labelSelectors:
      app: myapp
  stressors:
    memory:
      workers: 1
      size: '2GB'  # 2GBのメモリを消費
  duration: '2m'
```

---

### パターン5: データベース障害

**目的**: DB接続エラー時のリトライ・フォールバック検証

```python
# 手動でDBを停止してテスト
import psycopg2
from tenacity import retry, stop_after_attempt, wait_exponential

@retry(
    stop=stop_after_attempt(3),
    wait=wait_exponential(multiplier=1, min=1, max=10)
)
def get_user_with_retry(user_id):
    try:
        conn = psycopg2.connect(
            host="db.example.com",
            database="myapp",
            user="myapp",
            password="password",
            connect_timeout=3
        )
        cursor = conn.cursor()
        cursor.execute("SELECT * FROM users WHERE id = %s", (user_id,))
        return cursor.fetchone()
    except psycopg2.OperationalError as e:
        print(f"DB connection failed: {e}")
        raise
```

**テスト**:
```bash
# RDS障害注入
aws rds failover-db-cluster --db-cluster-identifier myapp-cluster

# アプリケーションの動作確認
curl http://api.example.com/users/1
```

---

### パターン6: 依存サービス障害

**目的**: 外部API障害時のサーキットブレーカー検証

```python
from circuitbreaker import circuit

@circuit(failure_threshold=5, recovery_timeout=30)
def call_external_api():
    response = httpx.get("https://external-api.example.com/data", timeout=5.0)
    if response.status_code != 200:
        raise Exception("API call failed")
    return response.json()

# フォールバック処理
def get_data_with_fallback():
    try:
        return call_external_api()
    except Exception:
        # サーキットブレーカーが開いた場合、キャッシュから取得
        return get_cached_data()
```

**障害注入**:
```bash
# 外部APIをブロック（iptables）
sudo iptables -A OUTPUT -d external-api.example.com -j DROP

# 5分後に解除
sleep 300
sudo iptables -D OUTPUT -d external-api.example.com -j DROP
```

---

## 🎯 Chaos実験の実施手順

### 1. 準備

```yaml
# 実験計画書
title: "ECSタスクランダム停止テスト"
hypothesis: "10%のタスクが停止しても、エラー率は0.1%未満を維持する"
blast_radius: "10%のタスク"
rollback: "CloudWatchアラームが発火したら即座に停止"
```

### 2. 実行

```bash
# モニタリング開始
datadog-agent start

# 負荷テスト開始
k6 run --vus 1000 --duration 10m load-test.js &

# 障害注入
aws fis start-experiment --experiment-template-id EXT1234567890

# 監視
watch -n 5 "aws cloudwatch get-metric-statistics --namespace AWS/ECS ..."
```

### 3. 観察

- ✅ エラー率の推移
- ✅ レスポンスタイムの推移
- ✅ ヘルスチェックの動作
- ✅ オートスケーリングの発動

### 4. 学習

```markdown
## 実験結果

### 成功
- ロードバランサーがヘルスチェックで検知（30秒）
- エラー率 0.05%（目標 < 0.1% 達成）

### 改善点
- オートスケーリングの発動まで2分かかった → 閾値を調整
```

---

**作成日**: 2025-10-19
**重要度**: ⭐⭐⭐
